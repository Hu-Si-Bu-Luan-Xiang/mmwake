version - 2023-03-23

    1. 修复配网之后无法读取stm串口数据的bug。
    2. all_config 增加 id_get 标志位，代表设备是否获取到服务器分配的 id 号，1 表示已获取， 0 表示还没获取到。
    3. 新增 配网按钮按下事件数据包，类型为0x02。
    4. 开机查nvs文件的wifi账号密码，自动连接wifi，连接失败则进入配网模式，一分钟配网不成功就重启。
    5. 待修改时间戳重复的问题........
    6. 待修复文件损坏无法重新读写的问题.........

version - 2023-03-24

    1. 修改LED任务指示灯状态对应的含义：

        红灯 ：      --- 闪烁：未连接上Wifi               --- 常亮：连接不上服务器             --- 常灭：连接上wifi且连接上服务器

        蓝灯 ：      --- 闪烁：进入配网模式              --- 常亮：未获取到时间                 --- 常灭：获取到了世界时间

        正常工作状态：两个灯均熄灭。

        异常工作状态：两灯相互交替闪烁，对应含义为文件系统损坏。注意区分：两灯同时闪烁意味着  未连接上Wifi、 等待配网。

        待解决：首次配网(擦除flash后首次配网)有问题......

    2. cood_data 函数修改成有返回值，目的是修正缺失和重复的时间戳，当连续出现 一个时间戳重复、相邻一个时间戳缺失 时，自动修补，争取使服务器收到的时间戳完美无缺。
        
        已成功解决时间戳缺失重复问题（由于STM32发来的时间不严格是1s，实际上会快一点，所有整体接收到的数据会多一些）。

        待解决：网络不好发送失败重传问题...

version - 2023-03-25

version - 2023-04-14

    1. 修复文件损坏无法重新读写的问题：当检测到文件无法正常打开读写时，格式化“storage”分区内存，并重启(已成功)；

    2. 当开机检测到“storage”内存分区的空闲内存小于1024 B 时，则清空分区内存并重启，待加入当hello.txt文件长度大于某个阈值时清空所有数据......

version - 2023-04-18

    1. 尝试做到TCP传输不丢包......（在服务器返回ID的数据包中，服务器会把该数据最后存入数据库的时间戳返回）

    2. 修改了rev_cood()下标可能溢出造成非法访问的bug，最多同时接收2个命令

    3. 发现断开服务器许久后，esp32的系统时间会出现严重偏差，故需要定时校正>>>>>>暂定一个小时校正一次时间

version - 2023-04-25

    1. 时钟每10分钟同步一次，已经做到很精确的时钟系统了。

    2. 已经做到TCP传输不丢包（除了电源不稳导致的STM32重启这段时间的数据丢失外），具体如下：

        之前数据丢失的原因：
            大量实验发现，之前代码丢失的数据大部分都是在网络不好socket断开的时候才丢失的，这是因为调用send函数没返回错误码就直接清空了文件系统存储的数据，但是实际上send函数只是把数据copy到TCP的发送缓冲区而已，而由于网络不好socket断开时，这部分数据没来得及发送到服务器，从而导致了数据丢包。

        解决方法：
            服务器端：在数据库设备状态表增加一列最后入表时间戳，以记录每个设备最后一个收到的数据包对应的时间戳。
            ESP32端：增加一个4KB的回收站缓冲区，以滑动窗口的方式保存send函数“发送成功”的数据；在每次socket断开重连时，都先向服务器申请查询最后入表的时间戳，然后去查找回收站缓冲区，发现存在没有发送成功的数据就重新发送。

    3. 修复一个小漏洞：
    
        在serial.c 的 rx_task(void *arg)增加一个用于存cood异常数据后的数据的缓存区info_out_cood，因为之前修正时间戳的代码对于正常数据跟STM异常数据包共用一个缓存区 data_out_cood的，导致
        出现STM异常数据包时会覆盖正常的数据包。

version - 2023-04-26

    1. 修改Flash的分区表

            # ESP-IDF Partition Table
            # Name,    Type,  SubType,  Offset,   Size,    Flags
            # nvs,       data,  nvs,      0x9000,   0x6000,  ,
            # phy_init,  data,  phy,      0xf000,   0x1000,  ,
            # factory,   app,   factory,  0x10000,  1M,      ,
            # storage,   data,  fat,      ,         2M,      ,

            # ESP-IDF Partition Table
            # Name,    Type,  SubType,  Offset,   Size,     Flags
            nvs,       data,  nvs,      0x9000,   0x4000,   ,
            otadata,   data,  ota,      0xd000,   0x2000,   ,
            phy_init,  data,  phy,      0xf000,   0x1000,   ,
            factory,   app,   factory,  0x10000,  0xE0000,  ,
            ota_0,     app,   ota_0,    0xF0000,  0xE0000,  ,
            ota_1,     app,   ota_1,    0x1D0000, 0xE0000,  ,
            storage,   data,  spiffs,   0x2B0000, 0x140000, ,

    2. 每满1024B才写入文件，每隔60秒才发送一次数据，降低读写文件的频率，降低文件损坏的可能。

version - 2023-04-27

    1. 尝试添加OTA功能...

version - 2023-05-03

    1. 修复bug: serial.c文件中 num_busy 存在先加但是data_txt_busy内存没有真正memcpy添加有效数据的可能（这种情况调用fatfs_write(file_path , data_txt_busy , BAG_LEN * num_busy)函数时可能出现内存越界访问问题）。

version - 2023-05-03_2

    1. 增加TCP发送超时功能，避免一直堵塞在send里面！

version - 2023-05-04

    1. 尝试添加OTA功能...

    2. 裁剪程序固件大小：
            powershell >> start cmd  
            idf.py menuconfig  
            # 进入该路径文件的idf编译配置
            Compiler options → Optimization Level 改成 Optimize for size (-Os)
            Compiler options → Assertion level 改成 Silent (saves code size)

Date: 2023-05-05  Versions 1.0.0

    1. 已经添加并了实现OTA（远程程序固件升级）的基础功能，能够通过http访问服务器URL链接远程下载并自动更新程序，但是目前程序是APP端按网络测试按键才启动固件更新的（为了方便测试），有待进一步完善相关功能...

    2. 从现在开始工程文件备份以日期命名，同时程序在mmwake.c文件定义一个常量的版本号，版本号命名规则：

            Versions X.Y.Z [主版本号.次版本号.修订号]

            X 主版本号：当软件整体重写，或出现不向后兼容的大改变时(例如更换Flash分区表、程序模块结构重塑等)， 主版本号递增 1 ，次版本清零，修订号清零，如 1.9.1 -> 2.0.0

            Y 次版本号：当添加新功能，或者其中功能有重大改变时（例如添加OTA功能等），主版本号不变，次版本号递增 1 ，修订号清零，如 1.5.1 -> 1.6.0

            Z 修订号  ：当修复程序存在的小Bug，或者对程序进行小优化时，主版号不变，次版本号不变，修订号递增 1
    
    3. 此程序还存在bug待修复：tcp调用recv()或者send()函数存在返回错误码128的情况没做处理（这个bug在version 2023-05-03_2时添加了TCP发送超时功能才出现的），有待解决...

Date: 2023-05-07  Versions 1.0.1

    1. 优化了程序变量（修改各变量类型至最佳，最小内存），全局增加了预编译宏：DEBUG，当不定义DEBUG时，设备将几乎不编译运行任何用于统计系统运行状态的代码和打印对应调试信息，可以有效减小程序固件的大小。
    
    2. 修复了上一版本tcp调用recv()或者send()函数存在返回错误码128的情况没做处理的bug，现在一有错误码直接断开Socket重新连接（重新查询最后入表时间戳，确保万无一失）。
    
    3. 通过log信息捕捉到send函数返回值大于0且不等于发送长度且不是BAG_LEN整数倍的情况，对于这种情况也是采取断开Socket重新连接，重新查询最后入表时间戳，确保万无一失）。
    
    目前所有设备均烧录了此版程序，正在测试中（2023-05-07 20:15:00）......

Date: 2023-05-08  Versions 1.0.2

    * 待修复关键bug: 对于因部分发送成功而中断的socket连接，在重连后，需要再次检查文件数据哪些已经被发送了，不然可能会造成重复发送的情况！！！

    此版本是一个专门为了在511展示项目的测试程序(配套STM程序Project_STM32F407_XC112_PCB_test20)：通过ESP32 USB线把接收到STM32发过来的位移差和基本体征数据转发到电脑展示出来，减免通过STM32 CH430串口转接模块传数据的麻烦。（USB-TTL的线很短，不方便从床垫下方延伸出来）主要做了以下修改：

        1. 注释所有info等级及以上的log信息，连接电脑的串口只转发收到来自STM32的原本数据，其他信息一概不打印。（其他任务基本保持不变在工作。）
        
        2. 对预编译宏 DEBUG 的使用范围将覆盖所有打印信息，并且覆盖一些不必要的任务和代码段。

Date: 2023-05-09 Versions 1.0.3

    1. 此版本修复关键bug: 对于因部分发送成功而中断的socket连接，在重连后，需要再次检查文件数据哪些已经被发送了，不然可能会造成重复发送的情况！！！（解决方式：在发送这种情况时，直接将部分发送的BAG_LEN整数倍长度的数据放到回收站中，更新文件待发送下标，再强制断开socket即可，这样重连后会检查是否漏发，也不会重发！）

    2. 增加ESP32启动就发一个重启数据包，包含当前程序运行版本号和ESP32重启时间。

    3. 增加OTA进度条功能（由于旧版库没有esp_https_ota_get_image_size函数直接从https://github.com/espressif/esp-idf/tree/17451f1fb3d6485af5113d96b6836a7ce60efee8/components/esp_https_ota 下载并更换最新的 esp_https_ota.c 和esp_https_ota.h 文件）。
    
    4. 增加OTA升级反馈OTA升级状态的数据包，具体请看通讯协议 https://www.kdocs.cn/l/cehqTbqdYrgt .

        ESP32 OTA进程数据包																
	    bit															
        0	    1	    2	     3	      4	       5	   6	     7	      8	  9	  10  11  12	  13	  14	  15
    	0x5a	标识位	ID高八位  ID低八位	OTA状态	 当前程序版本号			      当前时间戳	   留用位		   帧尾	   帧尾
        0x5a	0x0c	0x	     0x	      0x	  主版本号	次版本号  修订号	0x	0x	0x	0x	0xff	0xff	0x0d	0x0a
        bit4 反馈OTA的进程，取值：0x01(告诉已收到OTA升级指令) 0x02(版本相同或低级，无需升级) 0x04(升级失败) 0x0b-0x13(固件下载进度1/10-9/10) 0x14(固件完成下载)															

Date: 2023-05-23 Versions 1.1.0

    1. 新的硬件分离板修改了LED指示灯IO口：全部灯都由ESP32控制，控制IO为 4、5、6、7 ，分别对应 橙、蓝、红、绿 ，此版本程序LED灯的闪亮逻辑为：

        橙灯 ：      --- 闪烁：未连接上Wifi              --- 常亮：连接不上服务器             --- 常灭：连接上wifi且连接上服务器

        蓝灯 ：      --- 闪烁：进入配网模式              --- 常亮：未获取到时间               --- 常灭：获取到了世界时间

        红灯 ：      --- 闪烁：文件系统损坏              --- 常亮：雷达工作异常               --- 常灭：工作正常

        绿灯 ：      --- 闪烁：正常工作                  --- 常亮：正在进行固件升级           --- 常灭：单片机工作异常

Date: 2023-05-29 Versions 1.2.0(移植失败，不要用这个程序)

    1. 尝试添加 STM32 IAP 功能...(由于IAP所用的串口为UART1，跟接收STM32发过来体征数据的串口是一样的，同一时间STM32也只能正常运行或者进行固件升级，所以IAP功能加在serial.c文件里面会更加方便)

    2. ESP32串口引脚  RX：18， TX：19（以前是4）

Date: 2023-06-04 Versions 1.2.0

    1. 尝试添加 STM32 IAP 功能...

    2. 通过了初步的IAP联调测试，能够跑通STM32的固件升级包从 服务器 → ESP32 → STM32 的整个下载过程，其中用到了HTTP协议和Ymodem协议, STM32端对应的程序为Date：2023.06.07 Project: Bootloader。

Date: 2023-06-07 Versions 1.2.1

    1. 完善 STM32 IAP 功能 ... 这个版本已经完成了跟STM32 的 Date：2023.06.08 Project: Bootloader2 程序联调。

    2. 能够做到ESP32随时接收服务器传来的IAP固件升级指令（暂时是通过睡眠报告APP的网络测试按钮发送指令），并且ESP32接收指令后让STM32重启进入Bootloader程序（MODE_B），接着向STM32发升级指令，让STM32进入Ymodem下载模式(MODE_D)，然后ESP32开启 HTTP 连接，从URL链接的服务器下载指定的固件升级包，每下载 1K 数据就安照Ymodem协议打包发给STM32，STM32通过CRC校验无误后写入指定地址，完成整个固件的下载传输写入后，STM32进入下载完成的循环（MODE_C）,等待ESP32询问并发送是否跳转至新写入的APP程序（MODE_A）运行.

    3. 注意：每次调用 esp_http_client_read 函数下载数据后要留一定的延时时间，不然长时间的连续下载会使系统的空闲任务IDLE (CPU 0) 无法执行，会导致系统看门狗报错从而使整个下载失败！（IDLE (CPU 0) 是 ESP32 系统的空闲任务，当所有其他的任务都没有处理器时间时，系统将会运行此任务。它是由 FreeRTOS 内核自动创建的，其主要作用是让 ESP32 保持工作，从而维持系统的稳定。空闲任务不执行任何实际的工作，只是让 CPU 或其他设备保持活跃状态，并使系统有效地响应中断。当有其他任务需要使用 CPU 时间时，IDLE 任务会被挂起，对于 CPU 资源需要求较高的应用程序，需要小心平衡 IDLE 任务的占用时间和其他任务的执行时间，以达到最佳的系统性能。而在发生任务狗狂吠计时器超时的情况下，IDLE (CPU 0) 是最可能出现在未能重置任务狗狂吠计时器的任务列表中，因为当其他所有任务都忙于处理自己的任务时，IDLE (CPU 0) 是唯一没有主动重置狗狂吠计时器的任务。）
    最后测试发现每次下载完1K数据，执行vTaskDelay(300)函数 延时300ms就再也没有出现以上错误了！

    4. 待完善 IAP HTTP传输的 断点续传功能（实测中有时因为网络原因可能会下载途中失败，重新下载很浪费时间和资源）...

    5. IAP待完善与服务器的交互。

Date: 2023-06-08 Versions 1.2.2

    1. 完善了与服务器的IAP过程交互，升级进程类似于ESP32的OTA过程，详情请看腾讯云文档通讯协议。

    2. 完善了与STM32之间的交互，可以向STM32发送查询运行模式、重启、运行新APP等指令，STM32也会有相应的回应。
    
    3. STM32端采用 BootLoader + 双APP分区(一个保存出厂模式，另一个专门用于升级，就算升级失败也能运行出厂APP，不至于卡在BOOTLOADER程序里)升级的策略，STM32一共有1024KB的Flash，用户程序的基地址以及分区大小设置为：0-08008000：bootloader 08010000：更新区app有效标志分区 08020000-0805FFFF：出厂app分区（256KB） 08060000 -  ~   ：更新APP分区（512KB）
    （需要分别在BootLoader2、SleepMonitoringApp_1_0_0、SleepMonitoringApp_1_0_1 这三个STM32项目工程的 Core\Src\system_stm32f4xx.c 、 STM32F407ZGTX_FLASH.ld 、Drivers\CMSIS\Device\ST\STM32F4xx\include\stm32407xx.h 这三个文件对应的位置修改基地址和大小，这样子编译器才知道哪个程序需要烧录到Flash的哪个位置，占用空间多大。）
    
    4. 其中BootLoader2是启动必须运行的程序，它会等待ESP32发送下载更新APP指令一秒钟，若收到升级指令则运行下载固件的程序，若超时没收到升级指令则根据更新区app有效标志来判断要运行出厂模式的备份APP SleepMonitoringApp_1_0_0 还是 运行有效的 SleepMonitoringApp_1_0_1。
    
    5. SleepMonitoringApp_1_0_0 为工厂模式APP，这个APP存放着出厂时带有的最低版本的睡眠体征计算和监测程序，更新APP时这个分区的内容不会受到任何影响，这样就算更新区的APP下载更新失败，设备也可以运行出厂模的APP，不至于卡在升级程序中而停止对用户的睡眠监测。

    6. SleepMonitoringApp_1_0_1 是专门用于升级STM32睡眠体征提取算法的项目更新固件，其将被放在服务器特定的文件夹里面，通过 ESP32 开启建立 HTTP 连接，用 OTA 的方式把固件下载下来，ESP32 再通过串口用 Ymodem （一种文件传输协议）将下载到的固件块分包发送给STM32，STM32 解析没问题后就将其一段一段地写入预先规定好的Flash中（更新APP分区）, 完成远程程序升级。（这个过程就叫IAP In Application Programming）

    7. 待将Log等级改成 no output ...

Date: 2023-06-15 Versions 1.2.3

    1. 将Log等级改成 no output . ！！！ 会使跟STM32通讯的串口输出不正常 ！！！  (等级改成error、warn也不行,只有Info才能完成STM32的IAP升级！！！)

    2. 设备被老师拿去外面测试（对应设备id:10/11/12）...